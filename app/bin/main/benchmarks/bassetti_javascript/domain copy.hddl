; designed specifically to work with Teexma
; LIMMS server copy (https://ofir-servier-optiplan.teexma.local/teexma?idObject=47082) to be precise
; this is NON-temporal simplified domain
; every task lasts 1 hour
; there are 3 hierarchy levels
; - level 1: Studies
; -- level 2: Activities
; --- level 3: Tasks

;NOTE - CURRENT PLANNER DOESNT SUPPORT NEGATIVE GOALS (i.e. (not PREDICATE) in goals)

(define (domain bassetti-javascript1)

(:requirements :hierarchy
	  :typing
	  :method-preconditions
  :negative-preconditions
  :existential-preconditions
)

(:types study activity task resource place timeslot)

(:constants kitchen - place)

(:predicates (activity_has_tasks ?a - activity) (activity_is_primitive ?a - activity) (is_child ?t - task ?a - activity) (task_not_performed ?t - task)(activity_not_performed ?a - activity)
(activity_done ?a - activity) (task_done ?t - task)

)


(:task do_activity
  :parameters (?a - activity ))

(:task do_tasks
  :parameters (?a - activity))

; if activity has children tasks, we schedule the children
(:method m0_do_activity
  :parameters (?a - activity)
  :task (do_activity ?a)
  :precondition (and (activity_has_tasks ?a) (activity_not_performed ?a))
  :ordered-subtasks(and (t1 (do_tasks ?a))) )


; if activity has no children, we schedule the activity like we would a task
(:method m1_do_activity
  :parameters (?a - activity ?r - resource ?t - timeslot)
  :task (do_activity ?a)
  :precondition (and (activity_not_performed ?a) (activity_is_primitive ?a))
  :ordered-subtasks(and (t1 (schedule_activity ?a ?r ?t)))
) 


; m0_do_tasks is a recursive method that will try to perform some existing task for activity a, and then call itself again
; we need this recursivity because domain doesn't know how many tasks are there in an activity
(:method m0_do_tasks
  :parameters (?a - activity ?t - task ?r - resource ?tim - timeslot)
  :task (do_tasks ?a)
  :precondition (and (is_child ?t ?a) (task_not_performed ?t))
  :ordered-subtasks(and (t1 (schedule_task ?a ?t ?r ?tim)) (t2 (do_tasks ?a)) )
)

; m1_do_tasks serves as termination for the recursive m0_do_tasks
(:method m1_do_tasks
  :parameters (?a - activity)
  :task (do_tasks ?a)
  :ordered-subtasks(and (t1 (nop ?a)))
)

(:action schedule_activity
  :parameters (?a - activity ?r - resource ?t - timeslot)
  :precondition ()
  :effect(and (not(activity_not_performed ?a)) (activity_done ?a))
)

(:action schedule_task
  :parameters (?a - activity ?t - task ?r - resource ?tim - timeslot)
  :precondition ()
  :effect(and (not(task_not_performed ?t)) (not(activity_not_performed ?a)) (activity_done ?a) (task_done ?t))
)

(:action nop
  :parameters (?a - activity)
  :precondition (and (not(exists (?t - task) (and(is_child ?t ?a) (task_not_performed ?t)))))
  :effect ())
)
